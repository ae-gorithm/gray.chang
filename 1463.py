"""
단순해 보이는데, 시간 제한이 있다. 이 말은 최적화를 시키라는 말인데..
3으로 나눌 수 있으면 무조건 3으로 나눈다
만약 짝수라면 1을 빼냐 2로 나누냐 선택해야 한다.
선택의 기준은 그 다음 연산에서 3으로 나눌 수 있냐 없냐
나눌 수 있으면 1 빼고, 아니면 2로 나누기
"""
N = int(input())

dp = [0]*(N+1)
for i in range(2, N+1):
    dp[i] = dp[i-1] + 1 # 하나씩 뺄 경우
    if i%2 ==0:
        dp[i] = min(dp[i], dp[i//2]+1)
    if i%3==0:
        dp[i] = min(dp[i], dp[i//3]+1)

print(dp[N])
"""
list를 활용한 dp라는 것까지는 맞았으나, 리스트를 사용하는 방식이 틀렸다.
이번 문제의 경우 size가 N인 리스트를 사용하여 각 인덱스에 도달하는 최적의 숫자를 찾는 방식으로 진행한다.
해당 인덱스에 도달하는 방법은 (1부터 출발한다고 했을 때) 1씩 더하기, 2 곱하기, 3곱하기로, 2나 3으로 곱해서 도달할 수 있는 인덱스에서 dp하여 기억하며 된다. 
dp문제는 조금 더 풀어봐야겠다.
"""